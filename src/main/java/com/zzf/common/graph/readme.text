一 图的基本概念及存储结构
图G是由顶点的有穷集合，以及顶点之间的关系组成，顶点的集合记为V，顶点之间的关系构成边的集合E
G=(V,E).
说一条边从v1,连接到v2,那么有v1Ev2(E是V上的一个关系）《=》<v1,v2>∈E.
图有有向图，无向图之分，无向图的一条边相当于有向图的中两条边，即如果无向图的顶点v1和v2之间有一条边
，那么既有从v1连接到v2的边，也有从v2连接到v1的边，<v1,v2>∈E 并且<v2,v1>∈E，而有向图是严格区分方向的。

一般图的存储有两种方式
1）相邻矩阵，用一个矩阵来保持边的情况，<v1,v2>∈E则Matrix[v1][v2]=Weight.
2）邻接表，需要保存一个顺序存储的顶点表和每个顶点上的边的链接表。
这里的实现采用第二种方案，另外图又复杂图，简单图之分，复杂图可能在两点之间同一个方向有多条边，我们考虑的都是无环简单图，
无环简单图是指顶点没有自己指向自己的边的简单图，即任取vi属于V => <vi,vi>不属于E并且没有重复边。



二 深度优先周游
即从从某一点开始能继续往前就往前不能则回退到某一个还有边没访问的顶点，沿这条边看该边指向的点是否已访问，如果没有访问，那么从该指向的点继续操作。
那么什么时候结束呢，这里我们在图的ADT实现里加上一个标志数组。该数组记录某一顶点是否已访问，如果找不到不到能继续往前访问的未访问点，则结束。
你可能会问，如果指定图不是连通图（既有2个以上的连通分量）呢?
OK,解决这个问题，我们可以让每一个顶点都有机会从它开始周游。
下面看deepFirstTravel的实现



三 广度优先周游
广度优先周游从每个指定顶点开始，自顶向下一层一层的访问。上一层所有顶点访问完了才继续下一层的访问。可以把二叉树的广度优先周游看成图的广度优先周游的特例。
（二叉树是连通的无回路的有向图，也是一棵根树）同样，广度优先也要借助与一个队列来存储待访问顶点
下面是breathFirstTravel的实现，为了减小Java库的影响，我自己实现一个很简单的队列。（你也可以使用ArrayList,但是记住队列的定义，只能在头删除，在尾插入）：